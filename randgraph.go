// Copyright (c) 2025 Roi Martin
// Use of this source code is governed by the MIT license that can be
// found in the LICENSE file.

// Package randgraph implements random graph generators. Graphs are
// represented as streams of edges, so full graphs are not stored in
// memory, enabling the generation of graphs of arbitrary size.
package randgraph

import (
	"errors"
	"fmt"
	"io"
	"math/rand/v2"
	"strconv"
)

// An Edge connects two vertices, V0 and V1. In directed graphs, V0 is
// the tail vertex and V1 is the head vertex.
type Edge struct {
	V0, V1 string
}

// A Source is a source of random graphs.
type Source interface {
	// Graph returns a random graph represented as a stream of
	// edges.
	Graph() <-chan Edge

	// Directed reports whether the graphs generated by this
	// source are directed.
	Directed() bool
}

// A RandGraph wraps a [Source] to provide higher-level functionality.
type RandGraph struct {
	src Source
}

// New returns a new [RandGraph] that uses src to generate random
// graphs.
func New(src Source) *RandGraph {
	return &RandGraph{src: src}
}

// Graph returns a random graph represented as a stream of edges.
func (r *RandGraph) Graph() <-chan Edge {
	return r.src.Graph()
}

// Write writes a random graph to w in the following format:
//
//	"v0" ["v1"]
//	...
//
// Lines represent vertices and edges. A vertex consists of a line
// that contains the label of the vertex. An edge consists of a line
// that contains the labels of the two connected vertices, separated
// by a single space character. For directed graphs, the first label
// of the edge corresponds to the tail vertex and the second label
// corresponds to the head vertex.
func (r *RandGraph) Write(w io.Writer) {
	for edge := range r.src.Graph() {
		if edge.V1 != "" {
			fmt.Fprintf(w, "%q %q\n", edge.V0, edge.V1)
		} else {
			fmt.Fprintf(w, "%q\n", edge.V0)
		}
	}
}

// WriteDOT writes a random graph to w using the [DOT] language.
//
// [DOT]: https://graphviz.org/doc/info/lang.html
func (r *RandGraph) WriteDOT(w io.Writer) {
	var edgeop string
	if r.src.Directed() {
		fmt.Fprintln(w, "digraph {")
		edgeop = "->"
	} else {
		fmt.Fprintln(w, "graph {")
		edgeop = "--"
	}

	for edge := range r.Graph() {
		if edge.V1 != "" {
			fmt.Fprintf(w, "  %q %s %q\n", edge.V0, edgeop, edge.V1)
		} else {
			fmt.Fprintf(w, "  %q\n", edge.V0)
		}
	}
	fmt.Fprintln(w, "}")
}

// BinomialOpts are the [Binomial] parameters.
type BinomialOpts struct {
	// N is the number of trials.
	N int

	// P is the success probability for each trial.
	P float64

	// Vertices is the number of vertices.
	Vertices int

	// Loops defines whether loops are allowed.
	Loops bool

	// MultiEdges defines whether multiple edges are allowed. If
	// true, two or more edges with the same tail vertex and the
	// same head vertex are allowed.
	MultiEdges bool

	// Directed defines whether the generated graphs are directed.
	Directed bool

	// Labels contains the labels used for the vertices. If the
	// number of vertices exceeds the number of available labels,
	// then duplicated labels are suffixed with the vertex number.
	Labels []string
}

// Binomial implements the [Source] interface. It generates random
// graphs in which the number of edges created per vertex follows a
// binomial distribution.
type Binomial struct {
	opts BinomialOpts
	rand *rand.Rand
}

// NewBinomial returns a new [Binomial] with the provided parameters.
func NewBinomial(opts BinomialOpts) (*Binomial, error) {
	if opts.N < 0 {
		return nil, errors.New("invalid number of trials")
	}
	if opts.P < 0 || opts.P > 1 {
		return nil, errors.New("invalid success probability")
	}
	if opts.Vertices < 0 {
		return nil, errors.New("invalid number of vertices")
	}

	b := &Binomial{
		opts: opts,
		rand: rand.New(rand.NewPCG(rand.Uint64(), rand.Uint64())),
	}
	return b, nil
}

func (b *Binomial) Graph() <-chan Edge {
	ch := make(chan Edge)
	go func() {
		for itail := range b.opts.Vertices {
			tail := label(b.opts.Labels, itail)
			ch <- Edge{V0: tail}

			var start int
			if b.opts.Loops {
				start = 0
			} else {
				if itail == b.opts.Vertices-1 {
					// No possible heads.
					break
				}
				start = itail + 1
			}

			heads := make(map[int]struct{})
			for range b.opts.N {
				if b.rand.Float64() < b.opts.P {
					ihead := start + b.rand.IntN(b.opts.Vertices-start)
					if !b.opts.MultiEdges {
						if _, found := heads[ihead]; found {
							continue
						}
						heads[ihead] = struct{}{}
					}
					ch <- Edge{V0: tail, V1: label(b.opts.Labels, ihead)}
				}
			}
		}
		close(ch)
	}()
	return ch
}

func label(labels []string, n int) string {
	if len(labels) == 0 {
		return strconv.Itoa(n)
	}
	i := n % len(labels)
	if n < len(labels) {
		return labels[i]
	}
	return labels[i] + strconv.Itoa(n)
}

func (b *Binomial) Directed() bool {
	return b.opts.Directed
}
